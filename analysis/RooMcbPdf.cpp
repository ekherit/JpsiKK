/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 
#include <iostream>
using namespace std;

// Your description goes here... 

#include "Riostream.h" 

#include "RooMcbPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

//ClassImp(RooMcbPdf)

//_____________________________________________________________________________
RooMcbPdf::RooMcbPdf(const char *name, const char *title,
	      RooAbsReal & _X, //invariant mass 
				RooAbsReal & _Sigma,   //Common sigma
				RooAbsReal & _s1,   //staple
				RooAbsReal & _s2,   //staple 
				RooAbsReal & _s3,   //staple 
				RooAbsReal & _s4,   //staple 
				RooAbsReal & _s5,   //staple 
				RooAbsReal & _s6,   //staple 
				RooAbsReal & _s7,   //staple 
				RooAbsReal & _n1,   //staple 
				RooAbsReal & _n2   //staple 
				) : RooAbsPdf(name,title), 
   			fX("x","x",this,_X),
   			fSigma("sigma","sigma",this,_Sigma), 
   			fStaple1("staple1","staple1",this,_s1), 
   			fStaple2("staple2","staple2",this,_s2), 
   			fStaple3("staple3","staple3",this,_s3), 
   			fStaple4("staple4","staple4",this,_s4), 
   			fStaple5("staple5","staple5",this,_s5), 
   			fStaple6("staple6","staple6",this,_s6), 
   			fStaple7("staple7","staple7",this,_s7), 
   			fN1("nl","nl",this,_n1), 
   			fN2("nr","nr",this,_n2) 
{
	fType = TYPE_GEPE;
}

RooMcbPdf::RooMcbPdf(const char *name, const char *title,
	      RooAbsReal & _X, //invariant mass 
				RooAbsReal & _Sigma,   //Common sigma
				RooAbsReal & _s1,   //staple
				RooAbsReal & _s2,   //staple 
				RooAbsReal & _s3,   //staple 
				RooAbsReal & _s4,   //staple 
				RooAbsReal & _s5,   //staple 
				RooAbsReal & _n1,   //staple 
				RooAbsReal & _n2   //staple 
				) : RooAbsPdf(name,title), 
   			fX("x","x",this,_X),
   			fSigma("sigma","sigma",this,_Sigma), 
   			fStaple1("staple1","staple1",this,_s1), 
   			fStaple2("staple2","staple2",this,_s2), 
   			fStaple3("staple3","staple3",this,_s3), 
   			fStaple4("staple4","staple4",this,_s4), 
   			fStaple5("staple5","staple5",this,_s5), 
   			fN1("nl","nl",this,_n1), 
   			fN2("nr","nr",this,_n2) 
{
	fType = TYPE_GPE;
}

	


//_____________________________________________________________________________
RooMcbPdf::RooMcbPdf(const RooMcbPdf& other, const char* name) :
  RooAbsPdf(other,name), 
   fX("x",this,other.fX), 
	 fSigma("sigma",this,other.fSigma), 
	 fStaple1("staple1",this,other.fStaple1), 
	 fStaple2("staple2",this,other.fStaple2), 
	 fStaple3("staple3",this,other.fStaple3), 
	 fStaple4("staple4",this,other.fStaple4), 
	 fStaple5("staple5",this,other.fStaple5), 
	 fStaple6("staple6",this,other.fStaple6), 
	 fStaple7("staple7",this,other.fStaple7), 
	 fN1("nl",this,other.fN1), 
	 fN2("nr",this,other.fN2) 
{
	fType = other.fType;
}



//_____________________________________________________________________________
Double_t RooMcbPdf::evaluate() const 
{
	initArgs();
	double x = (fX - mean)/fSigma;
	int i = x < 0 ? 0 : 1; //tail index
	double y = TMath::Abs(x); //abs of x
	if(y>c[i]) return C[i]*exp(-(y-c[i])*kc[i]);
	if(y>b[i]) return B[i]*pow(1.0 + kb[i]*(y-b[i]),  -n[i]);
	if(y>a[i]) return A[i]*exp(-(y-a[i])*ka[i]);
	return exp(-0.5*y*y);
}


void RooMcbPdf::initArgs(void) const
{
	switch(fType)
	{
		case TYPE_GPE:
			mean_index = 2;
			staple.resize(5);
			break;
		case TYPE_GEPE:
			mean_index = 3;
			staple.resize(7);
			break;
	};
	//init staple points
	staple[0] = fStaple1;
	staple[1] = fStaple2;
	staple[2] = fStaple3;
	staple[3] = fStaple4;
	staple[4] = fStaple5;
	if(fType == TYPE_GEPE)
	{
		staple[5] = fStaple6;
		staple[6] = fStaple7;
	}
	//sort them
	std::sort(std::begin(staple), std::end(staple));
	mean = staple[mean_index];
	for(auto & s : staple)
	{
		s = (s-mean)/fSigma;
	}
	n[0] = fN1;
	n[1] = fN2;


	for(int i=0;i<2;i++)
	{
		int sign = i ==0 ? -1 : +1;
		a[i] = std::abs(staple[mean_index+1*sign]); 
		switch(fType)
		{
			case TYPE_GPE:
				b[i]=a[i];
				c[i] = std::abs(staple[mean_index+2*sign]);
				break;
			case TYPE_GEPE:
				b[i] = std::abs(staple[mean_index+2*sign]);
				c[i] = std::abs(staple[mean_index+3*sign]);
				break;
		}
	}

	for(int i=0;i<2;i++)
	{
		ka[i] =  a[i];
		kb[i] =  ka[i]/n[i];
		kc[i] =  n[i]*kb[i]/(1.0 + kb[i]*(c[i]-b[i]));
		A[i]  =  TMath::Exp(-0.5*a[i]*a[i]);
		B[i]  =  A[i]*TMath::Exp(- ka[i]*(b[i]-a[i]));
		C[i]  =  B[i]*pow( 1.0  + kb[i]*(c[i]-b[i]),  - n[i]);
		//cout << "A = " << A[i] << endl;
		//cout << "B = " << B[i] << endl;
		//cout << "C = " << C[i] << endl;
		//cout << i << "xb = " << xb[i] << endl;
	}
}


//_____________________________________________________________________________
Int_t RooMcbPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* ) const
{
  if (matchArgs(allVars,analVars,fX)) return 1 ;
  return 0;
}



//_____________________________________________________________________________
Double_t RooMcbPdf::analyticalIntegral(Int_t code, const char* rangeName) const
{
	initArgs();
	//cout << fX.max(rangeName) << " " << fX.min(rangeName) << endl;
	double xmax = (fX.max(rangeName) - mean)/fSigma;
	double xmin = (fX.min(rangeName) - mean)/fSigma;
	double IG[2]; //gauss part of integral
	double IA[2]; //exp part of integral
	double IB[2]; //power part of integral
	double IC[2]; //exp tail part of integral
	double I=0; //sum of previouse one
	double xrange[2]  = { fabs(xmin), fabs(xmax)};
	//std::cout << "xmin = " << xmin << " xmax = " << xmax << endl;
	for(int i=0;i<2;i++)
	{
		//cout << "a["<<i<<"]=" << a[i] << endl;
		//cout << "b["<<i<<"]=" << b[i] << endl;
		//cout << "c["<<i<<"]=" << c[i] << endl;
		//cout << "n["<<i<<"]=" << n[i] << endl;
		if(false) 
		{
			I+=xrange[i];
		}
		else 
		{
			//cout << " A["<< i<<"] = " << A[i] << endl;
			//cout << " B["<<i<<"] = " << B[i] << endl;
			//cout << " C["<<i<<"] = " << C[i] << endl;
			//cout << " ka["<<i<<"] = " << ka[i] << endl;
			//cout << " kc["<<i<<"] = " << kc[i] << endl;
			//cout << " kb["<<i<<"] = " << kb[i] << endl;
			if(xrange[i] < a[i])
			{
				IG[i]  =  sqrt(M_PI*0.5)*TMath::Erf(xrange[i]/sqrt(2.0));
				IA[i]  =  0;
				IB[i]  =  0;
				IC[i]  =  0;
			}
			if(a[i] <= xrange[i] < b[i])
			{
				IG[i]  =  sqrt(M_PI*0.5)*TMath::Erf(a[i]/sqrt(2.0));
				IA[i]  =  A[i]/ka[i]*( 1.0 -  TMath::Exp(- ka[i]*(xrange[i]-a[i])));
				IB[i]  =  0;
				IC[i]  =  0;
			}
			if(b[i] <= xrange[i] < c[i])
			{
				IG[i]  =  sqrt(M_PI*0.5)*TMath::Erf(a[i]/sqrt(2.0));
				//cout << IG[i] << endl;
				IA[i]  =  A[i]/ka[i]*( 1.0 -  TMath::Exp(- ka[i]*(b[i]-a[i])));
				if(n[i]==1.0) IB[i] = B[i]/kb[i]*log(1.0 +kb[i]*(xrange[i]-b[i]));
				else IB[i] = B[i]/kb[i]/(n[i]-1.0)*(1.0  - pow( 1.0 + kb[i]*(xrange[i]-b[i]), - n[i] + 1.));
			}
			if(c[i] <= xrange[i])
			{
				if(ka[i]>0)
				{
					IG[i]  =  sqrt(M_PI*0.5)*TMath::Erf(a[i]/sqrt(2.0));
					IA[i]  =  A[i]/ka[i]*( 1.0 -  TMath::Exp(- ka[i]*(b[i]-a[i])));
					if(n[i]>1.0) IB[i] = B[i]/kb[i]/(n[i]-1.0)*(1.0  - pow( 1.0 + kb[i]*(c[i]-b[i]), - n[i] + 1.));
					else IB[i] = B[i]/kb[i]*log(1.0 +kb[i]*(c[i]-b[i]));
					IC[i]  =  C[i]/kc[i]*( 1.0  - TMath::Exp(- kc[i]*(xrange[i] - c[i])));
				}
				else
				{
					IG[i] = 0;
					IA[i] = A[i]*(b[i]-a[i]);
					IB[i] = B[i]*(c[i]-b[i]);
					IC[i] = C[i]*(xrange[i]-c[i]);
				}
				//cout << " hit max range" << endl;
			}
			else
			{
				cout << "ERROR: wrong integral hit range" << endl;
			}
			//cout << "IG[" << i << "]=" << IG[i] << endl;
			//cout << "IA[" << i << "]=" << IA[i] << endl;
			//cout << "IB[" << i << "]=" << IB[i] << endl;
			//cout << "IC[" << i << "]=" << IC[i] << endl;
			I+=IG[i] + IA[i] + IB[i] + IC[i];
		}
	}
	//cout << "Itotal = " << I << endl;
	return I*fSigma;
}
