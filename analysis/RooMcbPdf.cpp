/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 
#include <iostream>
using namespace std;

// Your description goes here... 

#include "Riostream.h" 

#include "RooMcbPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

//ClassImp(RooMcbPdf)

//_____________________________________________________________________________
RooMcbPdf::RooMcbPdf(const char *name, const char *title,
	      RooAbsReal & _X, //invariant mass 
				RooAbsReal & _Sigma,   //Common sigma
				RooAbsReal & _s1,   //staple
				RooAbsReal & _s2,   //staple 
				RooAbsReal & _s3,   //staple 
				RooAbsReal & _s4,   //staple 
				RooAbsReal & _s5,   //staple 
				RooAbsReal & _s6,   //staple 
				RooAbsReal & _s7,   //staple 
				RooAbsReal & _n1,   //staple 
				RooAbsReal & _n2   //staple 
				//std::vector<RooRealVar> & _Staple, //Staple points
	      //std::vector<RooRealVar> & _N 
				) : RooAbsPdf(name,title), 
   			fX("x","x",this,_X),
   			fSigma("sigma","sigma",this,_Sigma), 
   			fStaple1("staple1","staple1",this,_s1), 
   			fStaple2("staple2","staple2",this,_s2), 
   			fStaple3("staple3","staple3",this,_s3), 
   			fStaple4("staple4","staple4",this,_s4), 
   			fStaple5("staple5","staple5",this,_s5), 
   			fStaple6("staple6","staple6",this,_s6), 
   			fStaple7("staple7","staple7",this,_s7), 
   			fN1("nl","nl",this,_n1), 
   			fN2("nr","nr",this,_n2) 
{
}



//_____________________________________________________________________________
RooMcbPdf::RooMcbPdf(const RooMcbPdf& other, const char* name) :
  RooAbsPdf(other,name), 
   fX("x",this,other.fX), 
	 fSigma("sigma",this,other.fSigma), 
	 fStaple1("staple1",this,other.fStaple1), 
	 fStaple2("staple2",this,other.fStaple2), 
	 fStaple3("staple3",this,other.fStaple3), 
	 fStaple4("staple4",this,other.fStaple4), 
	 fStaple5("staple5",this,other.fStaple5), 
	 fStaple6("staple6",this,other.fStaple6), 
	 fStaple7("staple7",this,other.fStaple7), 
	 fN1("nl",this,other.fN1), 
	 fN2("nr",this,other.fN2) 
{
}



//_____________________________________________________________________________
Double_t RooMcbPdf::evaluate() const 
{
	initArgs();
	double x = (fX - mean)/fSigma;
	//cout << "x = " << x << endl;

	int t = x < 0 ? 0 : 1; //tail index
	double y = TMath::Abs(x); //abs of x
	if(y>c[t]) return C[t]*exp(-(y-c[t])*kc[t]);
	if(y>b[t]) return B[t]*pow(xb[t]+y,  -n[t]);
	if(y>a[t]) return A[t]*exp(-(y-a[t])*ka[t]);
	return exp(-0.5*y*y);

}


void RooMcbPdf::initArgs(void) const
{
	//init staple points
	staple[0] = fStaple1;
	staple[1] = fStaple2;
	staple[2] = fStaple3;
	staple[3] = fStaple4;
	staple[4] = fStaple5;
	staple[5] = fStaple6;
	staple[6] = fStaple7;
	//sort them
	std::sort(std::begin(staple), std::end(staple));
	int mean_index = 3;
	mean = staple[mean_index];
	for(auto & s : staple)
	{
		s = (s-mean)/fSigma;
	}
	n[0] = fN1;
	n[1] = fN2;


	for(int i=0;i<2;i++)
	{
		int sign = i ==0 ? -1 : +1;
		a[i] = std::abs(staple[mean_index+1*sign]); 
		b[i] = std::abs(staple[mean_index+2*sign]);
		c[i] = std::abs(staple[mean_index+3*sign]);
		//cout << "a = " <<  a[i] << endl;
		//cout << " b= " << b[i] << endl;
		//cout << " c = " << c[i] << endl;
	}

	for(int i=0;i<2;i++)
	{
		A[i]  =  TMath::Exp(-0.5*a[i]*a[i]);
		ka[i] =  a[i];
		xb[i] =  n[i]/ka[i]  - b[i];
		B[i]  =  A[i]*pow(n[i]/ka[i], n[i])*TMath::Exp(- ka[i]*(b[i]-a[i]));
		C[i]  =  B[i]/pow( xb[i] + c[i],  n[i]);
		kc[i] =  n[i]/(xb[i]+c[i]);
		//cout << "A = " << A[i] << endl;
		//cout << "B = " << B[i] << endl;
		//cout << "C = " << C[i] << endl;
		//cout << i << "xb = " << xb[i] << endl;
	}
}


//_____________________________________________________________________________
Int_t RooMcbPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* ) const
{
  //if (matchArgs(allVars,analVars,fX)) return 1 ;
  return 0;
}



//_____________________________________________________________________________
Double_t RooMcbPdf::analyticalIntegral(Int_t code, const char* rangeName) const
{
	initArgs();
	//cout << fX.max(rangeName) << " " << fX.min(rangeName) << endl;
	double xmax = (fX.max(rangeName) - mean)/fSigma;
	double xmin = (fX.min(rangeName) - mean)/fSigma;
	double IG[2]; //gauss part of integral
	double IA[2]; //exp part of integral
	double IB[2]; //power part of integral
	double IC[2]; //exp tail part of integral
	double I=0; //sum of previouse one
	double xrange[2]  = { -xmin, +xmax};
	for(int i=0;i<2;i++)
	{
		IG[i]  =  sqrt(M_PI*0.5)*TMath::Erf(a[i]/sqrt(2.0));
		//cout << IG[i] << endl;
		IA[i]  =  A[i]/ka[i]*( 1.0 -  TMath::Exp(- ka[i]*(b[i]-a[i])));
		//cout << IA[i] << endl;
		if(n[i]==1.0) IB[i] = B[i]*log((xb[i] + c[i])/(xb[i] + b[i]));
		else IB[i] = B[i]/(n[i]-1.0)*(pow( xb[i] + b[i], - n[i] + 1.)  - pow( xb[i] + c[i], - n[i] + 1.));
		//cout << IB[i] << endl;
		IC[i]  =  C[i]/kc[i]*( 1.0  - TMath::Exp(- kc[i]*(xrange[i] - c[i])));
		//cout << IC[i] << endl;
		I+=IG[i] + IA[i] + IB[i] + IC[i];
		//cout << I << endl;
	}
	//cout << "Itotal = " << I << endl;
	return I;
}
